%% VRdata_training_rewards
% calculates the time and speed before rewards
% 
% make callable by pop_training_analysis?
% Input = VRdatafinal, generated by import_VRdata_training.m
% TODO fix bug such that indices, not absolute time points are returned by
% t_pre

function [t_pre, v_pre, v_post] = VRdata_training_rewards(VRdatafinal)
t = VRdatafinal(:,1);
allrewards = VRdatafinal(:,4);
nrewards = sum(allrewards);
n_samples = 500; %5 seconds of data

%%
if nrewards == 0
        t_pre = -1; %placeholder for infinite value
        v_pre=[];
        v_post=[];
        rew_index = NaN;
elseif nrewards == 1
    t_pre = t(allrewards == 1);
    rew_index = find(allrewards == 1);
    
else
    % if there is more than 1 reward
    r_times = t(allrewards ==1); % time of reward in seconds
    rew_index = find(allrewards == 1); %absolute index of reward times
    
    t_pre = NaN(length(r_times),1);
    % the first time is measured from beginning of rec
    t_pre(1) = r_times(1);
    % the remaining times are measured between rewards
    t_pre(2:end) = diff(r_times);
    
    v_pre = NaN(nrewards,501);
    v_post = NaN(nrewards,501);
end

if nrewards > 0 % if there are actually rewards
for n = 1:length(rew_index)
        if length(VRdatafinal) - n_samples < rew_index(n) % if the reward happens less then 5 secs before end of recording (unlikely!)
            v_pre(n,:) = VRdatafinal(rew_index(n) - n_samples: rew_index(n));
            pad_speed = NaN(1,length(VRdatafinal) - rew_index(n)); %calculate how many NaNs are needed to pad end of speed
            temp_speed = horzcat(VRdatafinal(rew_index(n):end,5),pad_speed); %concatenate real speed with NaNs
            v_post(n,:) = VRdatafinal(temp_speed,5);
            
        elseif rew_index < n_samples % if the first reward is less than 5 secs from the beginning of the recording
            pad_speed = NaN(1,rew_index(n)); %calculate how many NaNs are needed to pad beginning of speed
            temp_speed = horzcat(pad_speed,rew_index(n):n_samples); %concatenate real speed with NaNs TODO may throw bug for exact number of samples (500 vs. 501)
            v_pre(n,:) = VRdatafinal(temp_speed,5);
            v_post(n,:) = VRdatafinal(rew_index(n):rew_index(n) + n_samples,5);
            
        else %general case for rewards in the beginning of the rec
            v_pre(n,:) = VRdatafinal(rew_index(n)-n_samples:rew_index(n),5);
            v_post(n,:) = VRdatafinal(rew_index(n):rew_index(n) + n_samples,5);
        end
end

elseif nrewards == 1 %if there is exactly one reward
            if length(VRdatafinal) - n_samples < rew_index % if the reward happens less then 5 secs before end of recording (unlikely!)
            v_pre = VRdatafinal(rew_index - n_samples: rew_index);
            pad_speed = NaN(1,length(VRdatafinal) - rew_index); %calculate how many NaNs are needed to pad end of speed
            temp_speed = horzcat(VRdatafinal(rew_index:end),pad_speed); %concatenate real speed with NaNs
            v_post = VRdatafinal(temp_speed,5);
            
        elseif rew_index < n_samples % if the first reward is less than 5 secs from the beginning of the recording
            pad_speed = NaN(1,rew_index); %calculate how many NaNs are needed to pad beginning of speed
            temp_speed = horzcat(pad_speed,rew_index:n_samples); %concatenate real speed with NaNs TODO may throw bug for exact number of samples (500 vs. 501)
            v_pre = VRdatafinal(temp_speed,5);
            v_post = VRdatafinal(rew_index:rew_index + n_samples,5);
            
        else %general case for rewards in the beginning of the rec
            v_pre = VRdatafinal(rew_index-n_samples:rew_index,5);
            v_post = VRdatafinal(rew_index:rew_index + n_samples,5);
        end
    

end
end

% figure
% plot(v_pre')
% title('Pre-reward velocity')
% 
% figure
% plot(v_post')
% title('Post-reward velocity')
        